#!/bin/bash

# Adapted from THE UNIX PROGRAMMING ENVIRONMENT. A very complicated script w/
# very little practical purpose. Part of a primitive version-control suite
# along w/ its sister script "put"

set -e

PROGNAME=$(echo $0 | sed s#^.*/##)

show_usage() {
    echo $1
    echo "Usage: $PROGNAME [-v version] [-o outfile] file" 1>&2
    exit ${2:-1}
}

# check for the existence of the directory ~/.get; if a file exists by that
# name but isn't a directory, abort. if the directory does not exist, create
# it.
if [ -e ~/.get -a ! -d ~/.get ]; then
    show_usage "$PROGNAME: ~/.get exists but not a directory" 6
elif [ ! -e ~/.get ]; then
    mkdir ~/.get
fi

# check to see if ed is installed. if not, abort.
if ! command -v ed >/dev/null 2>&1
then
    show_usage "$PROGNAME: ed not installed" 1
fi

# "get remove FILE" removes the history file
if [[ "$1" == "remove" ]]; then
    rm ~/.get/$2.h
    exit $?
fi

VERSION=0
while test "$1" != ""
do
    case "$1" in
        -o) FILE=$2; shift   ;;
        -v) VERSION=$(($2 + 0)) 
            if [[ $VERSION == 0 ]]; then
                show_usage "$PROGNAME: invalid version specified" 2
            fi
            shift             ;;
        -*) show_usage "$0: unknown argument $1" 3 ;;
        # an argument that's not an option must be the name of the file. if 
        # an alternate outfile has not been specified, the outfile is the name
        # of the file. the input is always the history file named after the
        # the argument.
        *) case "$FILE" in 
               "") FILE=$1  ;;
                *) INPUT=~/.get/$1.H ;;
           esac
    esac
    shift
done

if [[ "$FILE" == "" ]]; then
    show_usage "$PROGNAME: No file specified." 1
fi

# if an alternate outfile has not been specified, INPUT is not set. set it to
# the name of the file.
INPUT=${INPUT:-~/.get/$FILE.H}

if [ ! -r $INPUT ] # "-r" means file is readable
then 
    show_usage "$PROGNAME: no file $INPUT" 4
fi

touch $FILE 2>/dev/null
if [ ! -r $FILE ]
then
    show_usage "$PROGNAME: cannot write to $FILE" 5
fi

trap 'rm -f /tmp/get.[ab]$$; exit 1' 1 2 15

# put unedited file in /tmp/get.a$$, put edit history in /tmp/get.b$$
sed <$INPUT -n '1,/^@@@/w /tmp/get.a'$$'
                /^@@@/,$w /tmp/get.b'$$

touch /tmp/get.b$$

# apply edits to /tmp/get.a$$
awk </tmp/get.b$$ '/^@@@/ { count++ }
                   !/^@@@/ && count > 0 && count <= '$VERSION'
                   END    { print "$d"; print "w", "'$FILE'" }' |
ed - /tmp/get.a$$  # ($d means to delete the last line)

# print the comment to stderr.
awk </tmp/get.b$$ '/^@@@/ { count++;
                            if (count == '$VERSION' + 1) 
                                for (i = 9; i <= NF; ++i)
                                    printf $i " ";            }
                   END    { if ('$VERSION' < count)
                                printf "\n"                   }' 1>&2

rm -f /tmp/get.[ab]$$
